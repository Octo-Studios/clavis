package it.hurts.octostudios.clavis.neoforge;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.core.Registry;
import net.minecraft.core.RegistryAccess;
import net.minecraft.core.registries.Registries;
import net.minecraft.server.MinecraftServer;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.Recipe;
import net.minecraft.world.item.crafting.RecipeHolder;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.server.ServerStartedEvent;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

@EventBusSubscriber
public class ItemValuator {
    private final MinecraftServer server;
    private final RegistryAccess.Frozen registryProvider;
    private final Map<Item, Double> valueMap = new HashMap<>();
    private final List<Recipe<?>> allRecipes;

    @SubscribeEvent
    public static void onServerStarted(ServerStartedEvent event) {
        ItemValuator valuator = new ItemValuator(event.getServer());

        valuator.computeAllValues();
        valuator.fillUnvaluedWithDefault();
        valuator.exportToJson();
    }

    public ItemValuator(MinecraftServer server) {
        this.server = server;
        this.registryProvider = server.registryAccess();
        this.allRecipes = loadAllRecipes(server);

        initBaseValues();
    }

    private static List<Recipe<?>> loadAllRecipes(MinecraftServer server) {
        return server.getRecipeManager()
                .getRecipes().stream()
                .map(RecipeHolder::value)
                .collect(Collectors.toList());
    }

    private void initBaseValues() {
        Set<Item> crafted = allRecipes.stream()
                .filter(r -> r.getResultItem(registryProvider) != null)
                .map(r -> r.getResultItem(registryProvider).getItem())
                .collect(Collectors.toSet());

        Registry<Item> reg = registryProvider.registryOrThrow(Registries.ITEM);
        for (Item item : reg) {
            if (!crafted.contains(item)) {
                valueMap.put(item, 1.0);
            }
        }
    }

    public void computeAllValues() {
        boolean changed;
        do {
            changed = false;
            for (Recipe<?> recipe : allRecipes) {
                ItemStack out = recipe.getResultItem(registryProvider);

                if (out == null) {
                    continue;
                }

                Item itm = out.getItem();
                if (valueMap.containsKey(itm)) continue;

                double sum = 0;
                boolean ok = true;

                for (Ingredient ing : recipe.getIngredients()) {
                    OptionalDouble any = Arrays.stream(ing.getItems())
                            .map(ItemStack::getItem)
                            .map(valueMap::get)
                            .filter(Objects::nonNull)
                            .mapToDouble(Double::doubleValue)
                            .min();

                    if (any.isEmpty()) {
                        ok = false;

                        break;
                    }

                    sum += any.getAsDouble();
                }

                if (!ok)
                    continue;

                double perUnit = sum / out.getCount();

                valueMap.put(itm, perUnit);

                changed = true;
            }
        } while (changed);
    }

    public void fillUnvaluedWithDefault() {
        Registry<Item> reg = registryProvider.registryOrThrow(Registries.ITEM);

        for (Item item : reg) {
            valueMap.putIfAbsent(item, 1.0);
        }
    }

    public void exportToJson() {
        List<Item> sortedItems = registryProvider
                .registryOrThrow(Registries.ITEM)
                .stream()
                .sorted(Comparator.comparingDouble(this::getValue).reversed())
                .toList();

        Map<String, Double> outMap = new LinkedHashMap<>();

        for (Item item : sortedItems) {
            String id = registryProvider.registryOrThrow(Registries.ITEM)
                    .getKey(item)
                    .toString();

            outMap.put(id, getValue(item));
        }

        Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .serializeSpecialFloatingPointValues()
                .create();

        File file = new File(server.getServerDirectory().toString(), "item_values.json");

        try (FileWriter writer = new FileWriter(file)) {
            gson.toJson(outMap, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public double getValue(Item item) {
        return valueMap.getOrDefault(item, 1.0);
    }
}