package it.hurts.octostudios.clavis.neoforge;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.core.Registry;
import net.minecraft.core.RegistryAccess;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tags.TagKey;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.Recipe;
import net.minecraft.world.item.crafting.RecipeHolder;
import net.neoforged.bus.api.SubscribeEvent;
import net.neoforged.fml.common.EventBusSubscriber;
import net.neoforged.neoforge.event.server.ServerStartedEvent;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

@EventBusSubscriber
public class ItemValuator {
    private final MinecraftServer server;
    private final RegistryAccess.Frozen registryProvider;
    private final Map<Item, Double> valueMap = new HashMap<>();
    private final List<Recipe<?>> allRecipes;

    private final List<BiFunction<ItemStack, Double, Double>> customAdjusters = new ArrayList<>();

    @SubscribeEvent
    public static void onServerStarted(ServerStartedEvent event) {
        ItemValuator valuator = new ItemValuator(event.getServer());
        valuator.computeAllValues();
        valuator.fillUnvaluedWithDefault();
        valuator.exportToJson();
    }

    public ItemValuator(MinecraftServer server) {
        this.server = server;
        this.registryProvider = server.registryAccess();
        this.allRecipes = loadAllRecipes(server);

        customAdjusters.add((stack, value) ->
                stack.is(TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath("c", "ingots"))) ? 4 : value
        );

        customAdjusters.add((stack, value) ->
                stack.is(TagKey.create(Registries.ITEM, ResourceLocation.fromNamespaceAndPath("c", "gems"))) ? 8 : value
        );

//        customAdjusters.add((stack, value) ->
//                value * (1 + stack.getRarity().ordinal() * 0.1)
//        );

        initBaseValues();
    }

    private static List<Recipe<?>> loadAllRecipes(MinecraftServer server) {
        return server.getRecipeManager()
                .getRecipes()
                .stream()
                .map(RecipeHolder::value)
                .collect(Collectors.toList());
    }

    private void initBaseValues() {
        Set<Item> crafted = allRecipes.stream()
                .filter(r -> r.getResultItem(registryProvider) != null)
                .map(r -> r.getResultItem(registryProvider).getItem())
                .collect(Collectors.toSet());

        Registry<Item> reg = registryProvider.registryOrThrow(Registries.ITEM);
        for (Item item : reg) {
            if (!crafted.contains(item)) {
                double base = applyCustomAdjusters(new ItemStack(item), 1.0);
                valueMap.put(item, base);
            }
        }
    }

    public void computeAllValues() {
        boolean changed;
        do {
            changed = false;
            for (Recipe<?> recipe : allRecipes) {
                ItemStack out = recipe.getResultItem(registryProvider);
                if (out == null) continue;
                Item itm = out.getItem();
                if (valueMap.containsKey(itm)) continue;

                double sum = 0;
                boolean ok = true;
                for (Ingredient ing : recipe.getIngredients()) {
                    OptionalDouble any = Arrays.stream(ing.getItems())
                            .map(ItemStack::getItem)
                            .map(valueMap::get)
                            .filter(Objects::nonNull)
                            .mapToDouble(Double::doubleValue)
                            .min();
                    if (any.isEmpty()) {
                        ok = false;
                        break;
                    }
                    sum += any.getAsDouble();
                }
                if (!ok) continue;

                double perUnit = sum / out.getCount();
                perUnit = applyCustomAdjusters(out, perUnit);

                valueMap.put(itm, perUnit);
                changed = true;
            }
        } while (changed);
    }

    public void fillUnvaluedWithDefault() {
        Registry<Item> reg = registryProvider.registryOrThrow(Registries.ITEM);
        for (Item item : reg) {
            valueMap.putIfAbsent(
                    item,
                    applyCustomAdjusters(new ItemStack(item), 1.0)
            );
        }
    }

    public void exportToJson() {
        List<Item> sortedItems = registryProvider
                .registryOrThrow(Registries.ITEM)
                .stream()
                .sorted(Comparator.comparingDouble(this::getValue).reversed())
                .toList();

        Map<String, Double> outMap = new LinkedHashMap<>();
        for (Item item : sortedItems) {
            String id = registryProvider
                    .registryOrThrow(Registries.ITEM)
                    .getKey(item)
                    .toString();
            outMap.put(id, getValue(item));
        }

        Gson gson = new GsonBuilder()
                .setPrettyPrinting()
                .serializeSpecialFloatingPointValues()
                .create();
        File file = new File(server.getServerDirectory().toString(), "item_values.json");
        try (FileWriter writer = new FileWriter(file)) {
            gson.toJson(outMap, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public double getValue(Item item) {
        return valueMap.getOrDefault(item, 0.0);
    }

    private double applyCustomAdjusters(ItemStack stack, double value) {
        for (BiFunction<ItemStack, Double, Double> adjuster : customAdjusters) {
            value = adjuster.apply(stack, value);
        }
        return value;
    }
}